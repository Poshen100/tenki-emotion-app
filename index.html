<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TENKI v26.0 - Supernova Entity</title>
    
    <!-- 核心引擎 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- UI 庫 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --bg-deep: #000000;
            --tei-flow: #00FF99;
            --tei-focus: #00F0FF;
            --tei-stress: #FF3333;
        }

        body {
            background: var(--bg-deep);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            width: 100vw; height: 100vh;
            margin: 0; padding: 0;
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #input-video, #process-canvas {
            position: fixed; top: -9999px; left: -9999px; opacity: 0; pointer-events: none;
        }

        /* 3D World - Full Screen & Centered */
        #universe {
            position: absolute; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #0a0f14 0%, #000000 90%);
        }

        /* HUD Layer */
        #hud-layer {
            position: absolute; inset: 0; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 24px;
        }

        /* Go Club Button (High Contrast, Snappy) */
        .go-btn {
            pointer-events: auto;
            background: #FFFFFF; color: #000000;
            font-weight: 800; font-size: 14px; letter-spacing: 1.5px;
            padding: 18px 42px;
            border-radius: 9999px;
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.2);
            transition: transform 0.05s linear;
            border: none; outline: none; text-transform: uppercase;
            display: flex; align-items: center; gap: 10px;
        }
        .go-btn:active { transform: scale(0.92); background: #EEEEEF; }

        /* Fingerprint Sensor */
        .fingerprint-sensor {
            pointer-events: auto;
            position: relative;
            width: 90px; height: 90px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(8px);
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .fingerprint-sensor:active { transform: scale(0.95); }
        .fingerprint-sensor.active {
            border-color: var(--tei-focus);
            background: rgba(0, 240, 255, 0.15);
            box-shadow: 0 0 60px var(--tei-focus);
            transform: scale(1.1);
        }

        /* Status Badges */
        .status-badge {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 10px; color: rgba(255,255,255,0.6);
            background: rgba(0,0,0,0.5);
        }
        .status-badge.active {
            border-color: var(--tei-flow);
            color: var(--tei-flow);
            background: rgba(0, 255, 153, 0.1);
        }

        /* Boot & Result Layers */
        #boot-layer, #result-overlay {
            position: absolute; inset: 0; 
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s ease;
        }
        #boot-layer { z-index: 100; background: black; color: var(--tei-flow); font-family: 'Courier New', monospace; }
        #result-overlay { 
            z-index: 50; background: rgba(0,0,0,0.95); 
            opacity: 0; pointer-events: none; backdrop-filter: blur(20px);
        }
        #result-overlay.show { opacity: 1; pointer-events: auto; }

        .score-big {
            font-size: 120px; font-weight: 800;
            background: linear-gradient(180deg, #fff, #666);
            -webkit-background-clip: text; color: transparent;
            letter-spacing: -6px; line-height: 1;
        }
    </style>
</head>
<body>
    <video id="input-video" playsinline></video>

    <div id="boot-layer">
        <div>> IGNITING SUPERNOVA...</div>
    </div>

    <div id="universe"></div>

    <div id="hud-layer">
        <div class="flex justify-between items-start">
            <div>
                <div class="text-2xl font-black tracking-widest text-white">TENKI</div>
                <div class="text-[9px] text-cyan-400 tracking-[0.2em] mt-1">v26.0 SUPERNOVA</div>
            </div>
            <div id="sensor-badge" class="status-badge">SENSORS: SEARCHING</div>
        </div>

        <div class="flex flex-col items-center pb-12">
            <div id="scan-trigger" class="fingerprint-sensor">
                <i data-lucide="fingerprint" class="w-10 h-10 text-white/70"></i>
            </div>
            <div id="instruction" class="mt-6 text-[10px] tracking-[4px] text-gray-400 font-mono uppercase">
                Initialize Soul Sync
            </div>
        </div>
    </div>

    <div id="result-overlay">
        <div class="text-[12px] font-bold tracking-[4px] text-gray-500 mb-4">TEI SCORE</div>
        <div class="score-big" id="final-score">--</div>
        <div id="state-text" class="mt-4 text-xl font-medium tracking-widest text-cyan-400">ANALYZING</div>
        
        <div class="grid grid-cols-3 gap-8 mt-16 text-center w-full px-8">
            <div><div class="text-2xl font-bold text-white" id="res-stab">--</div><div class="text-[10px] text-gray-500 mt-2">STABILITY</div></div>
            <div><div class="text-2xl font-bold text-white" id="res-ener">--</div><div class="text-[10px] text-gray-500 mt-2">ENERGY</div></div>
            <div><div class="text-2xl font-bold text-white" id="res-foc">--</div><div class="text-[10px] text-gray-500 mt-2">FOCUS</div></div>
        </div>

        <div class="mt-20">
            <button id="resync-btn" class="go-btn">
                <i data-lucide="zap" class="w-4 h-4"></i> RESYNC
            </button>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- 1. Supernova Shader Engine ---
        const Visuals = {
            scene: null, camera: null, renderer: null, material: null,
            init: function() {
                const container = document.getElementById('universe');
                this.scene = new THREE.Scene();
                
                // Camera Adjustment for Mobile (解決切邊問題)
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                // 如果是手機(直屏)，把鏡頭拉遠；如果是電腦(橫屏)，拉近
                this.camera.position.z = aspect < 1 ? 6.5 : 4.5;

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                // --- SUPERNOVA SHADER ---
                // 結合了 Noise(流動), Pulse(心跳), Turbulence(張嘴反應)
                const vertexShader = `
                    attribute float size; attribute float random;
                    uniform float uTime;
                    uniform float uMouth;   // 張嘴力度
                    uniform float uHeadX;   // 頭部 X
                    uniform float uHeadY;   // 頭部 Y
                    uniform float uPulse;   // 眨眼/掃描脈衝
                    
                    varying vec3 vColor;
                    varying float vAlpha;

                    // 簡單的偽隨機函數
                    float rand(vec2 co){
                        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                    }

                    void main() {
                        vec3 pos = position;

                        // 1. Living Idle (活體流動)
                        // 即使不動，粒子也會像深海生物一樣緩慢呼吸、浮動
                        float idleWave = sin(uTime * 1.5 + pos.y * 2.0) * 0.05;
                        pos.x += idleWave;
                        pos.z += cos(uTime * 1.0 + pos.x) * 0.05;

                        // 2. Interactive Drag (流體拖曳)
                        // 頭部轉動時，不僅僅是旋轉，而是帶有慣性的拖曳
                        pos.x += uHeadX * 3.0; 
                        pos.y += uHeadY * 3.0;
                        
                        // 3. Explosive Reactivity (張嘴反應)
                        // 張嘴時，粒子產生高頻震動 (Turbulence) 並向外擴散
                        float explosion = 1.0 + (uMouth * 2.5); // 放大 2.5倍
                        float jitter = rand(vec2(uTime, pos.x)) * uMouth * 0.15; // 震動
                        pos += normal * jitter;

                        // 4. Pulse Shockwave (眨眼)
                        float shockwave = 1.0 + uPulse * 0.5;

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        
                        // 計算最終大小
                        float finalSize = size * explosion * shockwave;
                        // 根據距離衰減大小，增加深度感
                        gl_PointSize = finalSize * (350.0 / -mvPosition.z);
                        
                        gl_Position = projectionMatrix * mvPosition;

                        // 5. Dynamic Color System
                        // 核心是青色(Teal)，邊緣是深藍，激動時變亮白
                        vec3 cIdle = vec3(0.0, 0.6, 0.8); // Ocean Blue
                        vec3 cActive = vec3(0.0, 1.0, 0.6); // Neon Green
                        vec3 cFlash = vec3(1.0, 1.0, 1.0);  // White

                        float activity = uMouth + uPulse;
                        vec3 finalColor = mix(cIdle, cActive, uMouth);
                        finalColor = mix(finalColor, cFlash, uPulse * 0.8);

                        vColor = finalColor;
                        vAlpha = 0.6 + (uMouth * 0.4) + (uPulse * 0.4);
                    }
                `;

                const fragmentShader = `
                    varying vec3 vColor; varying float vAlpha;
                    void main() {
                        // 圓形粒子 + 柔和光暈
                        float d = distance(gl_PointCoord, vec2(0.5));
                        if(d > 0.5) discard;
                        
                        // 核心亮，邊緣透
                        float glow = 1.0 - (d * 2.0);
                        glow = pow(glow, 2.5); // 增強核心亮度
                        
                        gl_FragColor = vec4(vColor, glow * vAlpha);
                    }
                `;

                // 增加粒子數量至 8000
                const geo = new THREE.BufferGeometry();
                const pos = [], rnd = [], sz = [];
                for(let i=0; i<8000; i++){
                    // Fibonacci Sphere 分佈，讓球體更均勻
                    const phi = Math.acos(-1 + (2 * i) / 8000);
                    const theta = Math.sqrt(8000 * Math.PI) * phi;
                    const r = 2.2 + Math.random() * 0.3; // 稍微有些厚度的球殼
                    
                    pos.push(r * Math.cos(theta) * Math.sin(phi));
                    pos.push(r * Math.sin(theta) * Math.sin(phi));
                    pos.push(r * Math.cos(phi));
                    
                    rnd.push(Math.random()); 
                    sz.push(0.1 + Math.random() * 0.1); // 大小隨機
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                geo.setAttribute('random', new THREE.Float32BufferAttribute(rnd,1));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));
                // 計算 normal 用於爆炸方向
                geo.computeVertexNormals();

                this.material = new THREE.ShaderMaterial({
                    uniforms: { 
                        uTime: {value:0}, uMouth: {value:0}, uHeadX: {value:0}, uHeadY: {value:0}, uPulse: {value:0}
                    },
                    vertexShader, fragmentShader, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                
                const points = new THREE.Points(geo, this.material);
                this.scene.add(points);

                // Animation Loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    const t = performance.now() * 0.001;
                    this.material.uniforms.uTime.value = t;

                    // 緩慢自轉 (Living Idle)
                    points.rotation.y = t * 0.05;
                    
                    // 脈衝衰減 (Pulse Decay)
                    this.material.uniforms.uPulse.value *= 0.9;

                    this.renderer.render(this.scene, this.camera);
                };
                animate();

                // Handle Resize (Fix Crop Issue)
                window.addEventListener('resize', () => {
                    const newAspect = window.innerWidth / window.innerHeight;
                    this.camera.aspect = newAspect;
                    this.camera.position.z = newAspect < 1 ? 6.5 : 4.5;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        };

        // --- 2. Input Processor (AI) ---
        const Inputs = {
            init: function() {
                const video = document.getElementById('input-video');
                const badge = document.getElementById('sensor-badge');
                
                const onResults = (res) => {
                    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                        const lm = res.multiFaceLandmarks[0];
                        const nose = lm[1];

                        // Update Badge
                        if(badge.innerText !== 'SENSORS: LOCKED') {
                            badge.innerText = 'SENSORS: LOCKED';
                            badge.classList.add('active');
                        }

                        // --- 1. Head Tracking (Direct & Inverted) ---
                        // 鏡像反轉，讓操作更直覺
                        const hx = (nose.x - 0.5) * -2.5;
                        const hy = (nose.y - 0.5) * -2.5;
                        Visuals.material.uniforms.uHeadX.value = hx;
                        Visuals.material.uniforms.uHeadY.value = hy;

                        // --- 2. Mouth (Hyper Sensitivity) ---
                        const lipDist = Math.abs(lm[13].y - lm[14].y);
                        // 放大倍率 12.0，微張嘴就有反應
                        let mouthOpen = Math.min(1.0, Math.max(0, (lipDist - 0.01) * 12.0));
                        Visuals.material.uniforms.uMouth.value = mouthOpen;

                        // --- 3. Blink (Pulse Trigger) ---
                        const leftEye = Math.abs(lm[159].y - lm[145].y);
                        if(leftEye < 0.015 && Visuals.material.uniforms.uPulse.value < 0.1) {
                            Visuals.material.uniforms.uPulse.value = 1.0; // Flash!
                        }

                        // Scanning Logic accumulator...
                        if(App.scanning) App.accumulate(mouthOpen, leftEye, hx, hy);

                    } else {
                        if(badge.innerText !== 'SENSORS: SEARCHING') {
                            badge.innerText = 'SENSORS: SEARCHING';
                            badge.classList.remove('active');
                        }
                    }
                };

                const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6});
                faceMesh.onResults(onResults);
                
                new Camera(video, {
                    onFrame: async () => await faceMesh.send({image: video}),
                    width: 640, height: 480
                }).start();
            }
        };

        // --- 3. App Logic ---
        const App = {
            scanning: false,
            acc: { mouth:0, eye:0, move:0, count:0 },
            
            init: function() {
                Visuals.init();
                Inputs.init();
                
                // Boot Fade
                setTimeout(() => {
                    document.getElementById('boot-layer').style.opacity = 0;
                    setTimeout(() => document.getElementById('boot-layer').style.display = 'none', 500);
                }, 1000);

                // Events
                const btn = document.getElementById('scan-trigger');
                const resync = document.getElementById('resync-btn');

                // Pointerdown for Instant Reaction (No Delay)
                btn.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    this.startScan();
                    btn.classList.add('active');
                    // Haptic
                    if(navigator.vibrate) navigator.vibrate(20);
                });

                resync.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    this.reset();
                    // Button Scale Animation
                    resync.style.transform = "scale(0.9)";
                    setTimeout(() => resync.style.transform = "scale(1)", 100);
                });
            },

            accumulate: function(m, e, x, y) {
                this.acc.mouth += m;
                this.acc.eye += e;
                this.acc.move += (Math.abs(x) + Math.abs(y));
                this.acc.count++;
            },

            startScan: function() {
                this.scanning = true;
                this.acc = {mouth:0, eye:0, move:0, count:0};
                document.getElementById('instruction').innerText = "SYNCING SOUL...";
                
                // Audio
                const ctx = new (window.AudioContext||window.webkitAudioContext)();
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.type='sawtooth'; o.frequency.value=80; o.frequency.exponentialRampToValueAtTime(600, ctx.currentTime+2);
                g.gain.value=0.1; g.gain.linearRampToValueAtTime(0, ctx.currentTime+2);
                o.connect(g); g.connect(ctx.destination); o.start();
                
                // Visual Pulse
                Visuals.material.uniforms.uPulse.value = 1.0;

                setTimeout(() => this.finishScan(), 2000);
            },

            finishScan: function() {
                this.scanning = false;
                document.getElementById('scan-trigger').classList.remove('active');
                
                // Calc Score
                const frames = this.acc.count || 1;
                const avgMouth = this.acc.mouth / frames;
                const avgMove = this.acc.move / frames; // Lower is better (Stability)
                
                // Simple TEI Logic
                let score = 50 + (1 - avgMove)*30 + (avgMouth)*20;
                score = Math.min(99, Math.max(1, Math.round(score)));
                
                // Show Result
                document.getElementById('final-score').innerText = score;
                document.getElementById('res-stab').innerText = Math.round((1-avgMove)*100) + '%';
                document.getElementById('res-ener').innerText = Math.round(avgMouth*100) + '%';
                document.getElementById('res-foc').innerText = Math.round(Math.random()*20+80) + '%';
                
                const stateText = document.getElementById('state-text');
                if(score > 80) { stateText.innerText = "FLOW STATE"; stateText.style.color = "#00FF99"; }
                else if(score > 60) { stateText.innerText = "FOCUSED"; stateText.style.color = "#00F0FF"; }
                else { stateText.innerText = "BALANCED"; stateText.style.color = "#FFDD00"; }

                document.getElementById('result-overlay').classList.add('show');
            },

            reset: function() {
                document.getElementById('result-overlay').classList.remove('show');
                document.getElementById('instruction').innerText = "INITIALIZE SOUL SYNC";
            }
        };

        window.onload = () => App.init();
    </script>
</body>
</html>
