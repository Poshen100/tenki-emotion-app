<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TENKI v33.0 - World Changer</title>
    
    <!-- Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* 1. NUCLEAR TOUCH PREVENTION (放大鏡殺手) */
        html, body {
            overflow: hidden;
            overscroll-behavior: none;
            -webkit-touch-callout: none; /* iOS 關鍵 */
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000000;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
            margin: 0; padding: 0;
            width: 100vw; height: 100vh;
        }

        #input-video { position: fixed; top: -999px; opacity: 0; pointer-events: none; }

        #universe {
            position: fixed; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #05080a 0%, #000000 100%);
        }

        /* HUD */
        #hud-layer {
            position: absolute; inset: 0; z-index: 20;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px 24px 60px 24px;
        }

        /* Guide Pill */
        #guide-pill {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 10px 24px;
            border-radius: 99px;
            display: flex; align-items: center; gap: 10px;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #guide-pill.locked {
            border-color: #00FF9D;
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.25);
        }
        #guide-text { font-size: 12px; font-weight: 700; letter-spacing: 2px; color: white; }

        /* 2. SCAN BUTTON (SVG Ring + Touch Area) */
        .scan-wrapper {
            pointer-events: auto; /* 允許互動 */
            position: relative;
            width: 110px; height: 110px;
            display: flex; justify-content: center; align-items: center;
            /* 防止 iOS 長按選單 */
            -webkit-touch-callout: none; 
        }

        .ring-svg {
            position: absolute; top: 0; left: 0;
            transform: rotate(-90deg);
            width: 110px; height: 110px;
            pointer-events: none;
        }
        .ring-circle {
            fill: none;
            stroke: #00FF9D;
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 314; /* 2 * PI * 50 */
            stroke-dashoffset: 314; /* Empty */
            transition: stroke-dashoffset 0s linear;
            opacity: 0;
        }
        .scan-wrapper.scanning .ring-circle { opacity: 1; }

        .scan-btn {
            width: 76px; height: 76px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; justify-content: center; align-items: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        .scan-wrapper.ready .scan-btn {
            background: rgba(255, 255, 255, 0.15);
            border-color: white;
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.1);
        }

        .scan-wrapper.active .scan-btn {
            transform: scale(0.92);
            background: rgba(0, 255, 157, 0.2);
            border-color: #00FF9D;
            box-shadow: inset 0 0 20px rgba(0, 255, 157, 0.3);
        }
        .scan-wrapper.active .scan-btn i { color: #00FF9D; transform: scale(1.1); }

        /* Shake Error */
        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-2px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, 0, 0); } 40%, 60% { transform: translate3d(6px, 0, 0); } }

        /* Result Overlay */
        #result-overlay {
            position: absolute; inset: 0; z-index: 50;
            background: black;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s ease;
        }
        #result-overlay.show { opacity: 1; pointer-events: auto; }

        /* 3. FIXED SCORE TEXT (防止切邊) */
        .score-hero {
            font-size: 140px; font-weight: 800; color: white;
            font-variant-numeric: tabular-nums;
            letter-spacing: -6px; line-height: 1;
            padding: 0 20px; /* 安全距離 */
            text-align: center;
            background: linear-gradient(180deg, #fff, #555);
            -webkit-background-clip: text; color: transparent;
        }

        /* 4. GO CLUB STYLE BUTTON (Neon Pill) */
        .go-btn {
            pointer-events: auto;
            position: relative;
            background: #00FF9D; /* Neon Green */
            color: #000000;
            padding: 18px 50px; 
            border-radius: 99px;
            font-weight: 800; font-size: 15px; letter-spacing: 1px;
            border: none;
            box-shadow: 0 10px 40px rgba(0, 255, 157, 0.4);
            transition: transform 0.1s, box-shadow 0.2s;
            display: flex; align-items: center; gap: 8px;
        }
        .go-btn:active { 
            transform: scale(0.94); 
            box-shadow: 0 5px 20px rgba(0, 255, 157, 0.3);
        }
        .go-btn i { stroke-width: 3px; }

    </style>
</head>
<body>
    <video id="input-video" playsinline></video>

    <div id="universe"></div>

    <div id="hud-layer">
        <div class="w-full flex justify-center">
            <div id="guide-pill">
                <span id="guide-text">INITIALIZING...</span>
            </div>
        </div>

        <div class="flex flex-col items-center">
            <div id="scan-wrapper" class="scan-wrapper">
                <svg class="ring-svg">
                    <circle id="ring-circle" class="ring-circle" cx="55" cy="55" r="50"></circle>
                </svg>
                <div class="scan-btn">
                    <i data-lucide="fingerprint" class="w-10 h-10 text-white/50 transition-all duration-300"></i>
                </div>
            </div>
            <div id="hint-text" class="mt-6 text-[10px] tracking-[3px] text-gray-500 font-bold uppercase transition-opacity duration-300 opacity-0">
                Hold to Scan
            </div>
        </div>
    </div>

    <div id="result-overlay">
        <div class="text-[10px] tracking-[6px] text-gray-500 mb-6 font-mono">TEI RESONANCE</div>
        <div class="score-hero" id="final-score">00</div>
        <div id="state-text" class="mt-4 text-xl font-bold tracking-[0.3em] text-cyan-400 opacity-0 transition-opacity duration-500">ANALYZING</div>
        <div class="mt-20">
            <button id="resync-btn" class="go-btn">
                <i data-lucide="refresh-cw" class="w-5 h-5"></i> REBOOT
            </button>
        </div>
    </div>

    <script>
        lucide.createIcons();
        // Global Right-Click Ban
        document.addEventListener('contextmenu', e => e.preventDefault());

        // --- 1. Visuals ---
        const Visuals = {
            scene: null, camera: null, renderer: null, mat: null,
            init: function() {
                const container = document.getElementById('universe');
                this.scene = new THREE.Scene();
                const asp = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, asp, 0.1, 1000);
                this.camera.position.z = asp < 1 ? 7.5 : 5.0;

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                const vertexShader = `
                    attribute float size; attribute float random;
                    uniform float uTime;
                    uniform float uEnergy;
                    uniform float uLock;
                    uniform float uWarp;
                    
                    varying vec3 vColor; varying float vAlpha;

                    void main() {
                        vec3 pos = position;

                        // 1. Magnetic Lock (Disperse/Condense)
                        float drift = (1.0 - uLock) * 1.0 * sin(pos.y + uTime);
                        pos += normal * drift;

                        // 2. Warp Drive (Symmetrical Burst Fix)
                        // When Warp starts (uWarp > 0), we don't apply head rotation.
                        // This ensures the burst is always straight forward.
                        // rotInfluence: 1 (normal) -> 0 (during warp)
                        float rotInfluence = 1.0 - smoothstep(0.0, 0.2, uWarp); 
                        
                        // Apply Energy Jitter (Before warp)
                        pos += normal * uEnergy * 0.1 * sin(uTime * 10.0 + pos.x);

                        // Warp Logic
                        float wz = uWarp * 30.0; // Fly closer
                        pos.z += wz;
                        float spread = 1.0 + uWarp * 6.0;
                        pos.x *= spread; 
                        pos.y *= spread;

                        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
                        float s = size * (0.5 + uLock * 0.5 + uEnergy + uWarp * 8.0);
                        gl_PointSize = s * (400.0 / -mvPos.z);
                        gl_Position = projectionMatrix * mvPos;

                        vec3 cDim = vec3(0.1, 0.2, 0.3);
                        vec3 cLock = vec3(0.0, 1.0, 0.8);
                        vec3 cBurst = vec3(1.0, 1.0, 1.0);
                        
                        vec3 c = mix(cDim, cLock, uLock);
                        c = mix(c, cBurst, uWarp);
                        
                        vColor = c;
                        vAlpha = 0.3 + uLock * 0.7;
                    }
                `;

                const geo = new THREE.BufferGeometry();
                const pos=[], rnd=[], sz=[];
                for(let i=0; i<12000; i++){
                    const phi = Math.acos(-1 + (2*i)/12000);
                    const theta = Math.sqrt(12000 * Math.PI) * phi;
                    const r = 2.0 + Math.random()*0.3;
                    pos.push(r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi));
                    rnd.push(Math.random()); sz.push(0.05 + Math.random()*0.1);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                geo.setAttribute('random', new THREE.Float32BufferAttribute(rnd,1));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));

                this.mat = new THREE.ShaderMaterial({
                    uniforms: { uTime:{value:0}, uEnergy:{value:0}, uLock:{value:0}, uWarp:{value:0} },
                    vertexShader: vertexShader, fragmentShader: `varying vec3 vColor; varying float vAlpha; void main() { float d=distance(gl_PointCoord,vec2(0.5)); if(d>0.5)discard; float g=1.0-(d*2.0); g=pow(g,2.0); gl_FragColor=vec4(vColor,g*vAlpha); }`,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.scene.add(new THREE.Points(geo, this.mat));

                const anim = () => {
                    requestAnimationFrame(anim);
                    this.mat.uniforms.uTime.value = performance.now()*0.001;
                    
                    // Slow rotation only when not warping
                    if(this.mat.uniforms.uWarp.value < 0.1) {
                        this.scene.rotation.y += 0.001;
                    } else {
                        // Reset rotation smoothly during warp for perfect symmetry
                        this.scene.rotation.y *= 0.9;
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                };
                anim();
            }
        };

        // --- 2. Logic ---
        const App = {
            locked: false,
            lockVal: 0,
            
            init: function() {
                Visuals.init();
                this.initAI();
                this.initUI();
            },

            initAI: function() {
                const guideText = document.getElementById('guide-text');
                const guidePill = document.getElementById('guide-pill');
                const wrapper = document.getElementById('scan-wrapper');
                const hint = document.getElementById('hint-text');

                const onResults = (res) => {
                    let targetLock = 0;
                    let msg = "SEARCHING...";
                    let isReady = false;

                    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                        const nose = res.multiFaceLandmarks[0][1];
                        const lm = res.multiFaceLandmarks[0];
                        
                        const mx = 1.0 - nose.x; // Mirror
                        const my = nose.y;
                        const dx = mx - 0.5;
                        const dy = my - 0.5;

                        // Precise Guidance
                        if (dx < -0.1) msg = "MOVE RIGHT →";
                        else if (dx > 0.1) msg = "← MOVE LEFT";
                        else if (dy < -0.15) msg = "↓ MOVE DOWN";
                        else if (dy > 0.15) msg = "↑ MOVE UP";
                        else {
                            msg = "PERFECT LOCK";
                            isReady = true;
                            targetLock = 1.0;
                        }

                        const mouth = Math.min(1, Math.abs(lm[13].y-lm[14].y)*15);
                        Visuals.mat.uniforms.uEnergy.value = mouth;

                    } else {
                        targetLock = 0.0;
                        msg = "NO FACE DETECTED";
                    }

                    guideText.innerText = msg;
                    
                    if (isReady) {
                        guidePill.classList.add('locked');
                        wrapper.classList.add('ready');
                        hint.style.opacity = 1;
                        this.locked = true;
                    } else {
                        guidePill.classList.remove('locked');
                        wrapper.classList.remove('ready');
                        hint.style.opacity = 0;
                        this.locked = false;
                    }

                    this.lockVal += (targetLock - this.lockVal) * 0.1;
                    Visuals.mat.uniforms.uLock.value = this.lockVal;
                };

                const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6});
                faceMesh.onResults(onResults);
                
                new Camera(document.getElementById('input-video'), { onFrame: async () => await faceMesh.send({image: document.getElementById('input-video')}), width: 640, height: 480 }).start();
            },

            initUI: function() {
                const wrapper = document.getElementById('scan-wrapper');
                const ringCircle = document.getElementById('ring-circle');
                const resync = document.getElementById('resync-btn');
                const overlay = document.getElementById('result-overlay');
                let scanTimer = null;

                // --- ROBUST TOUCH EVENTS ---
                // 使用 touchstart + preventDefault 是唯一能完全禁止 iOS 放大鏡的方法
                const start = (e) => {
                    if(e.cancelable) e.preventDefault(); // Stop iOS magnifier
                    if (!this.locked) {
                        wrapper.classList.add('shake');
                        setTimeout(()=>wrapper.classList.remove('shake'), 400);
                        return;
                    }

                    wrapper.classList.add('active');
                    wrapper.classList.add('scanning');
                    
                    // Ring Animation
                    ringCircle.style.transition = "stroke-dashoffset 2s linear";
                    ringCircle.style.strokeDashoffset = "0";

                    AudioFX.start();

                    scanTimer = setTimeout(() => this.completeScan(), 2000);
                };

                const end = (e) => {
                    if(e.cancelable) e.preventDefault();
                    if (scanTimer) clearTimeout(scanTimer);
                    scanTimer = null;
                    
                    wrapper.classList.remove('active');
                    wrapper.classList.remove('scanning');
                    
                    // Reset Ring
                    ringCircle.style.transition = "stroke-dashoffset 0.2s ease-out";
                    ringCircle.style.strokeDashoffset = "314";
                    
                    AudioFX.stop();
                };

                wrapper.addEventListener('touchstart', start, {passive: false});
                wrapper.addEventListener('touchend', end, {passive: false});
                // Mouse fallback
                wrapper.addEventListener('mousedown', start);
                wrapper.addEventListener('mouseup', end);
                wrapper.addEventListener('mouseleave', end);

                // Reboot
                resync.addEventListener('click', (e) => {
                    overlay.classList.remove('show');
                    Visuals.mat.uniforms.uWarp.value = 0;
                    document.getElementById('state-text').style.opacity = 0;
                    end(e);
                });
            },

            completeScan: function() {
                document.getElementById('scan-wrapper').classList.remove('active');
                
                let start = performance.now();
                const frame = (now) => {
                    let p = (now - start) / 1500;
                    if(p>1) p=1;
                    Visuals.mat.uniforms.uWarp.value = Math.pow(p, 4); // Exp burst
                    if(p<1) requestAnimationFrame(frame);
                    else this.showResult();
                };
                requestAnimationFrame(frame);
                
                AudioFX.success();
            },

            showResult: function() {
                const finalScore = Math.floor(Math.random()*(99-78)+78);
                const scoreEl = document.getElementById('final-score');
                let rolls = 0;
                const rollInterval = setInterval(() => {
                    scoreEl.innerText = Math.floor(Math.random()*99);
                    rolls++;
                    if(rolls > 25) {
                        clearInterval(rollInterval);
                        scoreEl.innerText = finalScore;
                        const st = document.getElementById('state-text');
                        st.style.opacity = 1;
                        st.innerText = finalScore > 90 ? "FLOW STATE" : "OPTIMAL";
                        st.style.color = finalScore > 90 ? "#00FF9D" : "#00F0FF";
                    }
                }, 30);

                document.getElementById('result-overlay').classList.add('show');
            }
        };

        const AudioFX = {
            ctx: null, osc: null, gain: null,
            init: function() { if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); },
            start: function() {
                this.init(); if(this.ctx.state === 'suspended') this.ctx.resume();
                const t = this.ctx.currentTime;
                this.osc = this.ctx.createOscillator(); this.gain = this.ctx.createGain();
                this.osc.type = 'sawtooth';
                this.osc.frequency.setValueAtTime(60, t);
                this.osc.frequency.linearRampToValueAtTime(400, t+2);
                this.gain.gain.setValueAtTime(0.1, t);
                this.gain.gain.linearRampToValueAtTime(0.3, t+2);
                this.osc.connect(this.gain); this.gain.connect(this.ctx.destination);
                this.osc.start(t);
            },
            stop: function() {
                if(this.osc) { 
                    const t = this.ctx.currentTime;
                    this.gain.gain.linearRampToValueAtTime(0, t+0.1);
                    this.osc.stop(t+0.1); this.osc=null; 
                }
            },
            success: function() {
                this.stop();
                const t = this.ctx.currentTime;
                const o = this.ctx.createOscillator(); o.type='sine';
                o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(800, t+0.1);
                const g = this.ctx.createGain(); g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0, t+0.5);
                o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+0.5);
            }
        };

        window.onload = () => App.init();
    </script>
</body>
</html>
