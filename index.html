<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TENKI v32.0 - Precision Ring</title>
    
    <!-- Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        * { -webkit-tap-highlight-color: transparent; user-select: none; }

        body {
            background: #000000;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", sans-serif;
            overflow: hidden;
            width: 100vw; height: 100vh;
            margin: 0; padding: 0;
        }

        #input-video { position: fixed; top: -9999px; opacity: 0; pointer-events: none; }

        /* 3D Scene */
        #universe {
            position: fixed; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #05080a 0%, #000000 100%);
        }

        /* HUD Layer */
        #hud-layer {
            position: absolute; inset: 0; z-index: 20;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px 24px 60px 24px;
        }

        /* 1. Precision Guide Pill (方向指示) */
        #guide-pill {
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 10px 24px;
            border-radius: 99px;
            display: flex; align-items: center; gap: 10px;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        #guide-pill.locked {
            border-color: #00FF9D;
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.2);
        }
        #guide-text { font-size: 12px; font-weight: 700; letter-spacing: 2px; color: white; }
        .arrow { font-size: 14px; color: #FF3333; font-weight: bold; }

        /* 2. PPG Ring Button (按住掃描) */
        .scan-wrapper {
            pointer-events: auto;
            position: relative;
            width: 100px; height: 100px;
            display: flex; justify-content: center; align-items: center;
        }

        /* The SVG Ring */
        .ring-svg {
            position: absolute; top: 0; left: 0;
            transform: rotate(-90deg); /* Start from top */
            width: 100px; height: 100px;
            pointer-events: none;
        }
        .ring-circle {
            fill: none;
            stroke: #00FF9D;
            stroke-width: 3;
            stroke-dasharray: 283; /* 2 * PI * r(45) */
            stroke-dashoffset: 283; /* Initially empty */
            transition: stroke-dashoffset 0s linear; /* Controlled by JS */
            opacity: 0;
        }
        .scan-wrapper.scanning .ring-circle {
            opacity: 1;
            /* 2秒充滿動畫由 JS 控制，這裡只負責顯現 */
        }

        /* Inner Button */
        .scan-btn {
            width: 72px; height: 72px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; justify-content: center; align-items: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }
        
        /* Locked State (Ready to press) */
        .scan-wrapper.ready .scan-btn {
            background: rgba(255, 255, 255, 0.15);
            border-color: white;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        /* Active State (Pressing) */
        .scan-wrapper.active .scan-btn {
            transform: scale(0.9);
            background: rgba(0, 255, 157, 0.2);
            border-color: #00FF9D;
        }
        .scan-wrapper.active .scan-btn i { color: #00FF9D; }

        /* Error Shake */
        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        /* Result Overlay */
        #result-overlay {
            position: absolute; inset: 0; z-index: 50;
            background: black;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s ease;
        }
        #result-overlay.show { opacity: 1; pointer-events: auto; }

        .score-hero {
            font-size: 140px; font-weight: 800; color: white;
            font-variant-numeric: tabular-nums;
            letter-spacing: -8px; line-height: 0.8;
            background: linear-gradient(180deg, #fff, #666);
            -webkit-background-clip: text; color: transparent;
        }

        .restart-btn {
            pointer-events: auto;
            background: white; color: black;
            padding: 16px 40px; border-radius: 99px;
            font-weight: 700; letter-spacing: 1px;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <video id="input-video" playsinline></video>

    <div id="universe"></div>

    <!-- HUD -->
    <div id="hud-layer">
        <!-- Top Guide -->
        <div class="w-full flex justify-center">
            <div id="guide-pill">
                <span id="guide-text">INITIALIZING...</span>
            </div>
        </div>

        <!-- Bottom Trigger with Ring -->
        <div class="flex flex-col items-center">
            <div id="scan-wrapper" class="scan-wrapper">
                <!-- SVG Ring -->
                <svg class="ring-svg">
                    <circle id="ring-circle" class="ring-circle" cx="50" cy="50" r="45"></circle>
                </svg>
                
                <div class="scan-btn">
                    <i data-lucide="fingerprint" class="w-9 h-9 text-white/50 transition-colors"></i>
                </div>
            </div>
            <div id="hint-text" class="mt-6 text-[10px] tracking-[3px] text-gray-500 font-bold uppercase transition-opacity duration-300 opacity-0">
                Hold to Scan
            </div>
        </div>
    </div>

    <!-- Result -->
    <div id="result-overlay">
        <div class="text-[10px] tracking-[6px] text-gray-500 mb-8 font-mono">TEI RESONANCE</div>
        <div class="score-hero" id="final-score">00</div>
        <div id="state-text" class="mt-6 text-xl font-bold tracking-[0.3em] text-cyan-400 opacity-0 transition-opacity duration-500">ANALYZING</div>
        <div class="mt-24">
            <button id="resync-btn" class="restart-btn">REBOOT SYSTEM</button>
        </div>
    </div>

    <script>
        lucide.createIcons();
        document.addEventListener('contextmenu', e => e.preventDefault());

        // --- 1. Visuals ---
        const Visuals = {
            scene: null, camera: null, renderer: null, mat: null,
            init: function() {
                const container = document.getElementById('universe');
                this.scene = new THREE.Scene();
                const asp = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, asp, 0.1, 1000);
                this.camera.position.z = asp < 1 ? 7.5 : 5.0;

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                // Shader: Fixed Position, Only Rotation
                const vertexShader = `
                    attribute float size; attribute float random;
                    uniform float uTime;
                    uniform float uEnergy;
                    uniform float uLock;
                    uniform float uWarp;
                    
                    varying vec3 vColor; varying float vAlpha;

                    void main() {
                        vec3 pos = position;

                        // 1. Magnetic Lock (Disperse/Condense)
                        // This visually shows "Alignment"
                        float drift = (1.0 - uLock) * 1.0 * sin(pos.y + uTime);
                        pos += normal * drift;

                        // 2. Warp Drive (Burst)
                        float wz = uWarp * 25.0;
                        pos.z += wz;
                        float spread = 1.0 + uWarp * 5.0;
                        pos.x *= spread; pos.y *= spread;

                        // 3. Energy Jitter (Mouth)
                        pos += normal * uEnergy * 0.1 * sin(uTime * 10.0 + pos.x);

                        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
                        float s = size * (0.5 + uLock * 0.5 + uEnergy + uWarp * 6.0);
                        gl_PointSize = s * (400.0 / -mvPos.z);
                        gl_Position = projectionMatrix * mvPos;

                        vec3 cDim = vec3(0.1, 0.2, 0.3);
                        vec3 cLock = vec3(0.0, 1.0, 0.8);
                        vec3 cBurst = vec3(1.0, 1.0, 1.0);
                        
                        vColor = mix(cDim, cLock, uLock);
                        vColor = mix(vColor, cBurst, uWarp);
                        vAlpha = 0.3 + uLock * 0.7;
                    }
                `;

                const geo = new THREE.BufferGeometry();
                const pos=[], rnd=[], sz=[];
                for(let i=0; i<10000; i++){
                    const phi = Math.acos(-1 + (2*i)/10000);
                    const theta = Math.sqrt(10000 * Math.PI) * phi;
                    const r = 2.0 + Math.random()*0.3;
                    pos.push(r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi));
                    rnd.push(Math.random()); sz.push(0.05 + Math.random()*0.1);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                geo.setAttribute('random', new THREE.Float32BufferAttribute(rnd,1));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));

                this.mat = new THREE.ShaderMaterial({
                    uniforms: { uTime:{value:0}, uEnergy:{value:0}, uLock:{value:0}, uWarp:{value:0} },
                    vertexShader: vertexShader, fragmentShader: `varying vec3 vColor; varying float vAlpha; void main() { float d=distance(gl_PointCoord,vec2(0.5)); if(d>0.5)discard; float g=1.0-(d*2.0); g=pow(g,2.0); gl_FragColor=vec4(vColor,g*vAlpha); }`,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.scene.add(new THREE.Points(geo, this.mat));

                const anim = () => {
                    requestAnimationFrame(anim);
                    this.mat.uniforms.uTime.value = performance.now()*0.001;
                    this.scene.rotation.y += 0.001; // Constant slow rotation
                    this.renderer.render(this.scene, this.camera);
                };
                anim();
            }
        };

        // --- 2. Logic & Guidance ---
        const App = {
            locked: false,
            lockVal: 0,
            
            init: function() {
                Visuals.init();
                this.initAI();
                this.initUI();
            },

            initAI: function() {
                const video = document.getElementById('input-video');
                const guidePill = document.getElementById('guide-pill');
                const guideText = document.getElementById('guide-text');
                const wrapper = document.getElementById('scan-wrapper');
                const hint = document.getElementById('hint-text');

                const onResults = (res) => {
                    let targetLock = 0;
                    let msg = "SEARCHING...";
                    let isReady = false;

                    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                        const nose = res.multiFaceLandmarks[0][1];
                        const lm = res.multiFaceLandmarks[0];
                        
                        // RAW Coordinates (0-1)
                        // x: 0(left) -> 1(right) relative to image
                        // Mirror for UI logic: 
                        const mx = 1.0 - nose.x; 
                        const my = nose.y;

                        // Center Target: 0.5, 0.5
                        // Tolerances
                        const dx = mx - 0.5;
                        const dy = my - 0.5;

                        // --- DIRECTIONAL GUIDANCE ---
                        if (dx < -0.1) {
                            msg = "MOVE RIGHT →"; 
                        } else if (dx > 0.1) {
                            msg = "← MOVE LEFT";
                        } else if (dy < -0.15) { // Head too high
                            msg = "↓ MOVE DOWN";
                        } else if (dy > 0.15) { // Head too low
                            msg = "↑ MOVE UP";
                        } else {
                            // Perfect Center
                            msg = "PERFECT LOCK";
                            isReady = true;
                            targetLock = 1.0;
                        }

                        // Energy (Mouth)
                        const mouth = Math.min(1, Math.abs(lm[13].y-lm[14].y)*15);
                        Visuals.mat.uniforms.uEnergy.value = mouth;

                    } else {
                        targetLock = 0.0;
                        msg = "NO FACE DETECTED";
                    }

                    // UI Updates
                    guideText.innerText = msg;
                    
                    if (isReady) {
                        guidePill.classList.add('locked');
                        wrapper.classList.add('ready');
                        hint.style.opacity = 1;
                        this.locked = true;
                    } else {
                        guidePill.classList.remove('locked');
                        wrapper.classList.remove('ready');
                        hint.style.opacity = 0;
                        this.locked = false;
                    }

                    // Smooth Lock Value
                    this.lockVal += (targetLock - this.lockVal) * 0.1;
                    Visuals.mat.uniforms.uLock.value = this.lockVal;
                };

                const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6});
                faceMesh.onResults(onResults);
                
                new Camera(video, { onFrame: async () => await faceMesh.send({image: video}), width: 640, height: 480 }).start();
            },

            initUI: function() {
                const wrapper = document.getElementById('scan-wrapper');
                const ringCircle = document.getElementById('ring-circle');
                const resync = document.getElementById('resync-btn');
                const overlay = document.getElementById('result-overlay');
                let scanTimer = null;
                let scanStartTime = 0;

                // --- PRESS & HOLD LOGIC (PPG Ring) ---
                const startScan = (e) => {
                    if (!this.locked) {
                        // Shake if pressed while not ready
                        wrapper.classList.add('shake');
                        setTimeout(()=>wrapper.classList.remove('shake'), 400);
                        return;
                    }

                    wrapper.classList.add('active');
                    wrapper.classList.add('scanning');
                    
                    // Start Ring Animation via CSS/JS
                    ringCircle.style.transition = "stroke-dashoffset 2s linear";
                    ringCircle.style.strokeDashoffset = "0"; // Fill ring

                    // Audio Start
                    AudioFX.start();

                    // Timer for completion (2s)
                    scanStartTime = Date.now();
                    scanTimer = setTimeout(() => {
                        this.completeScan();
                    }, 2000);
                };

                const cancelScan = (e) => {
                    if (scanTimer) clearTimeout(scanTimer);
                    scanTimer = null;
                    
                    wrapper.classList.remove('active');
                    wrapper.classList.remove('scanning');
                    
                    // Reset Ring
                    ringCircle.style.transition = "stroke-dashoffset 0.2s ease-out";
                    ringCircle.style.strokeDashoffset = "283"; // Empty ring
                    
                    AudioFX.stop();
                };

                // Pointer events cover both touch and mouse
                wrapper.addEventListener('pointerdown', startScan);
                wrapper.addEventListener('pointerup', cancelScan);
                wrapper.addEventListener('pointerleave', cancelScan);

                // Reboot
                resync.addEventListener('click', () => {
                    overlay.classList.remove('show');
                    Visuals.mat.uniforms.uWarp.value = 0;
                    document.getElementById('state-text').style.opacity = 0;
                    cancelScan();
                });
            },

            completeScan: function() {
                // Success!
                document.getElementById('scan-wrapper').classList.remove('active');
                
                // Burst Animation
                let start = performance.now();
                const frame = (now) => {
                    let p = (now - start) / 1500;
                    if(p>1) p=1;
                    Visuals.mat.uniforms.uWarp.value = p * p * p * p; // Exponential burst
                    if(p<1) requestAnimationFrame(frame);
                    else this.showResult();
                };
                requestAnimationFrame(frame);
                
                AudioFX.success();
            },

            showResult: function() {
                const finalScore = Math.floor(Math.random()*(99-72)+72);
                
                const scoreEl = document.getElementById('final-score');
                let rolls = 0;
                const rollInterval = setInterval(() => {
                    scoreEl.innerText = Math.floor(Math.random()*99);
                    rolls++;
                    if(rolls > 20) {
                        clearInterval(rollInterval);
                        scoreEl.innerText = finalScore;
                        const st = document.getElementById('state-text');
                        st.style.opacity = 1;
                        st.innerText = finalScore > 90 ? "FLOW STATE" : "OPTIMAL";
                        st.style.color = finalScore > 90 ? "#00FF9D" : "#00F0FF";
                    }
                }, 30);

                document.getElementById('result-overlay').classList.add('show');
            }
        };

        // Simple Audio
        const AudioFX = {
            ctx: null, osc: null, gain: null,
            init: function() { if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); },
            start: function() {
                this.init(); if(this.ctx.state === 'suspended') this.ctx.resume();
                const t = this.ctx.currentTime;
                this.osc = this.ctx.createOscillator();
                this.gain = this.ctx.createGain();
                this.osc.type = 'sawtooth';
                this.osc.frequency.setValueAtTime(60, t);
                this.osc.frequency.linearRampToValueAtTime(300, t+2); // Rising pitch
                this.gain.gain.setValueAtTime(0.1, t);
                this.gain.gain.linearRampToValueAtTime(0.3, t+2);
                this.osc.connect(this.gain); this.gain.connect(this.ctx.destination);
                this.osc.start(t);
            },
            stop: function() {
                if(this.osc) { 
                    const t = this.ctx.currentTime;
                    this.gain.gain.linearRampToValueAtTime(0, t+0.1);
                    this.osc.stop(t+0.1); this.osc=null; 
                }
            },
            success: function() {
                this.stop();
                const t = this.ctx.currentTime;
                const o = this.ctx.createOscillator(); o.type='sine';
                o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(800, t+0.1);
                const g = this.ctx.createGain(); g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0, t+0.5);
                o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+0.5);
            }
        };

        window.onload = () => App.init();
    </script>
</body>
</html>
