<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TENKI v31.0 - Apple Grade</title>
    
    <!-- Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* 1. NUCLEAR TOUCH FIXES (絕對禁止放大鏡) */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none; /* 全局禁止瀏覽器手勢 */
        }

        body {
            background: #000000;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            width: 100vw; height: 100vh;
            margin: 0; padding: 0;
        }

        #input-video { position: fixed; top: -999px; opacity: 0; pointer-events: none; }

        /* 3D Scene */
        #universe {
            position: fixed; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #05080a 0%, #000000 120%);
        }

        /* HUD Layer */
        #hud-layer {
            position: absolute; inset: 0; z-index: 20;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px 24px 60px 24px;
        }

        /* 2. Apple-Style Guidance (智慧導引) */
        #guide-pill {
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 12px 24px;
            border-radius: 99px;
            display: flex; align-items: center; gap: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translateY(0); opacity: 1;
        }
        #guide-pill.hidden { transform: translateY(-20px); opacity: 0; }
        
        #guide-icon { color: #FF3333; transition: color 0.3s; }
        #guide-text { font-size: 13px; font-weight: 600; letter-spacing: 1px; color: white; text-transform: uppercase; }
        
        /* Locked State */
        #guide-pill.locked { border-color: #00FF9D; background: rgba(0, 255, 157, 0.1); }
        #guide-pill.locked #guide-icon { color: #00FF9D; }

        /* 3. The Solid Button (堅實按鈕) */
        .scan-container {
            position: relative;
            width: 100px; height: 100px;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; /* 允許點擊 */
        }

        /* Outer Glow Ring (Breathing) */
        .scan-ring {
            position: absolute; inset: 0;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }
        .scan-container.ready .scan-ring {
            border-color: #00FF9D;
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.2);
            animation: pulse-ring 2s infinite ease-in-out;
        }

        /* Inner Button */
        .scan-btn {
            width: 70px; height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex; justify-content: center; align-items: center;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(5px);
        }
        
        /* Active States */
        .scan-container.ready .scan-btn { background: rgba(255, 255, 255, 0.2); cursor: pointer; }
        .scan-container.active .scan-btn { 
            transform: scale(0.9); /* 物理下壓感 */
            background: #00FF9D;
            box-shadow: 0 0 50px #00FF9D; 
        }
        .scan-container.active .scan-btn i { color: black; }

        @keyframes pulse-ring {
            0% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.5; }
        }

        /* Result Overlay */
        #result-overlay {
            position: absolute; inset: 0; z-index: 50;
            background: black;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s ease;
        }
        #result-overlay.show { opacity: 1; pointer-events: auto; }

        /* 4. Sci-Fi Number (Glitch Font) */
        .score-hero {
            font-size: 140px; font-weight: 800; color: white;
            font-variant-numeric: tabular-nums; /* 等寬數字，避免跳動時抖動 */
            letter-spacing: -8px; line-height: 0.8;
            text-shadow: 0 0 40px rgba(255,255,255,0.4);
        }

        .restart-btn {
            pointer-events: auto;
            background: white; color: black;
            padding: 16px 40px; border-radius: 99px;
            font-weight: 700; letter-spacing: 1px;
            transition: transform 0.1s;
        }
        .restart-btn:active { transform: scale(0.95); }
    </style>
</head>
<body>
    <video id="input-video" playsinline></video>

    <div id="universe"></div>

    <!-- HUD -->
    <div id="hud-layer">
        <!-- Top Guidance Pill -->
        <div class="w-full flex justify-center">
            <div id="guide-pill">
                <i id="guide-icon" data-lucide="scan-face" class="w-5 h-5"></i>
                <span id="guide-text">INITIALIZING...</span>
            </div>
        </div>

        <!-- Bottom Trigger -->
        <div class="flex flex-col items-center">
            <div id="scan-wrapper" class="scan-container">
                <div class="scan-ring"></div>
                <div class="scan-btn">
                    <i data-lucide="fingerprint" class="w-8 h-8 text-white transition-colors"></i>
                </div>
            </div>
            <div id="hint-text" class="mt-6 text-[10px] tracking-[3px] text-gray-500 font-bold uppercase transition-opacity duration-300 opacity-0">
                Tap to Scan
            </div>
        </div>
    </div>

    <!-- Result -->
    <div id="result-overlay">
        <div class="text-[10px] tracking-[6px] text-gray-500 mb-8 font-mono">TEI RESONANCE</div>
        <!-- Digital Rolling Number -->
        <div class="score-hero" id="final-score">00</div>
        
        <div id="state-text" class="mt-6 text-xl font-bold tracking-[0.3em] text-cyan-400 opacity-0 transition-opacity duration-1000">ANALYZING</div>
        
        <div class="mt-24">
            <button id="resync-btn" class="restart-btn">REBOOT SYSTEM</button>
        </div>
    </div>

    <script>
        lucide.createIcons();
        
        // --- 1. Visual Engine (The Burst) ---
        const Visuals = {
            scene: null, camera: null, renderer: null, mat: null,
            init: function() {
                const container = document.getElementById('universe');
                this.scene = new THREE.Scene();
                const asp = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, asp, 0.1, 1000);
                this.camera.position.z = asp < 1 ? 7.5 : 5.0; // Mobile distance fix

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                // Shader
                const vertexShader = `
                    attribute float size; attribute float random;
                    uniform float uTime;
                    uniform float uEnergy;  
                    uniform float uLock;    // 0 -> 1 (Alignment)
                    uniform float uWarp;    // 0 -> 1 (Burst)
                    uniform vec2 uHead;
                    
                    varying vec3 vColor; varying float vAlpha;

                    // Simple noise
                    float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }

                    void main() {
                        vec3 pos = position;

                        // 1. Lock Interaction (Magnetism)
                        // Unlocked: Particles drift apart (Noise)
                        // Locked: Particles snap to sphere
                        float drift = (1.0 - uLock) * 2.0 * sin(pos.x + uTime);
                        pos += normal * drift;

                        // 2. Rotation
                        float rx = uHead.x * 2.0; float ry = uHead.y * 2.0;
                        mat3 rot = mat3(cos(rx),0,sin(rx), 0,1,0, -sin(rx),0,cos(rx));
                        pos = rot * pos;

                        // 3. Warp Burst (Unbound)
                        // Exponential Z-move + X/Y Spread
                        float wz = uWarp * 25.0;
                        pos.z += wz;
                        float spread = 1.0 + uWarp * 5.0;
                        pos.x *= spread; pos.y *= spread;

                        // 4. Energy Jitter
                        pos += normal * uEnergy * 0.2 * rand(vec2(uTime, pos.z));

                        vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
                        
                        // Size: Bigger when locked or bursting
                        float s = size * (0.5 + uLock * 0.5 + uEnergy + uWarp * 6.0);
                        gl_PointSize = s * (400.0 / -mvPos.z);
                        gl_Position = projectionMatrix * mvPos;

                        // Color: Dim Blue -> Bright Cyan -> White
                        vec3 cDim = vec3(0.1, 0.2, 0.4);
                        vec3 cLock = vec3(0.0, 1.0, 0.8);
                        vec3 cBurst = vec3(1.0, 1.0, 1.0);
                        
                        vec3 c = mix(cDim, cLock, uLock);
                        c = mix(c, cBurst, uWarp);
                        
                        vColor = c;
                        vAlpha = 0.4 + uLock * 0.6;
                    }
                `;

                // 12k Particles
                const geo = new THREE.BufferGeometry();
                const pos=[], rnd=[], sz=[];
                for(let i=0; i<12000; i++){
                    const phi = Math.acos(-1 + (2*i)/12000);
                    const theta = Math.sqrt(12000 * Math.PI) * phi;
                    const r = 2.0 + Math.random()*0.3;
                    pos.push(r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi));
                    rnd.push(Math.random()); sz.push(0.05 + Math.random()*0.1);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                geo.setAttribute('random', new THREE.Float32BufferAttribute(rnd,1));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));
                geo.computeVertexNormals();

                this.mat = new THREE.ShaderMaterial({
                    uniforms: { uTime:{value:0}, uEnergy:{value:0}, uLock:{value:0}, uWarp:{value:0}, uHead:{value:new THREE.Vector2()} },
                    vertexShader, fragmentShader: `varying vec3 vColor; varying float vAlpha; void main() { float d=distance(gl_PointCoord,vec2(0.5)); if(d>0.5)discard; float g=1.0-(d*2.0); g=pow(g,2.0); gl_FragColor=vec4(vColor,g*vAlpha); }`,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.scene.add(new THREE.Points(geo, this.mat));

                const anim = () => {
                    requestAnimationFrame(anim);
                    this.mat.uniforms.uTime.value = performance.now()*0.001;
                    this.scene.rotation.y += 0.001;
                    this.renderer.render(this.scene, this.camera);
                };
                anim();
            }
        };

        // --- 2. Logic & Guidance ---
        const App = {
            locked: false,
            lockVal: 0,
            
            init: function() {
                Visuals.init();
                this.initAI();
                this.initUI();
            },

            initAI: function() {
                const video = document.getElementById('input-video');
                const guidePill = document.getElementById('guide-pill');
                const guideText = document.getElementById('guide-text');
                const guideIcon = document.getElementById('guide-icon');
                const wrapper = document.getElementById('scan-wrapper');
                const hint = document.getElementById('hint-text');

                const onResults = (res) => {
                    let targetLock = 0;
                    let msg = "SEARCHING FACE...";
                    let iconColor = "#FF3333";
                    let isReady = false;

                    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                        const nose = res.multiFaceLandmarks[0][1];
                        const lm = res.multiFaceLandmarks[0];
                        
                        // Mirror Correction
                        const mx = 1.0 - nose.x;
                        const my = nose.y;
                        
                        // Face Width (Distance estimation)
                        // Left Ear (234) to Right Ear (454)
                        const width = Math.abs(lm[234].x - lm[454].x);

                        // --- INTELLIGENT GUIDANCE LOGIC ---
                        if (width < 0.35) {
                            msg = "MOVE CLOSER"; // 太遠
                        } else if (width > 0.7) {
                            msg = "MOVE BACK";   // 太近
                        } else if (mx < 0.35) {
                            msg = "MOVE RIGHT";  // 偏左
                        } else if (mx > 0.65) {
                            msg = "MOVE LEFT";   // 偏右
                        } else if (my < 0.35) {
                            msg = "MOVE DOWN";
                        } else if (my > 0.7) {
                            msg = "MOVE UP";
                        } else {
                            // Perfect
                            msg = "PERFECT LOCK";
                            iconColor = "#00FF9D";
                            isReady = true;
                            targetLock = 1.0;
                        }

                        // Pass Head Rot to Visuals
                        Visuals.mat.uniforms.uHead.value.set((mx-0.5)*-2, (my-0.5)*-2);
                        // Mouth Energy
                        const mouth = Math.min(1, Math.abs(lm[13].y-lm[14].y)*15);
                        Visuals.mat.uniforms.uEnergy.value = mouth;

                    } else {
                        targetLock = 0.0;
                    }

                    // UI Updates
                    guideText.innerText = msg;
                    guideIcon.style.color = iconColor;
                    
                    if (isReady) {
                        guidePill.classList.add('locked');
                        wrapper.classList.add('ready');
                        hint.style.opacity = 1;
                        this.locked = true;
                    } else {
                        guidePill.classList.remove('locked');
                        wrapper.classList.remove('ready');
                        hint.style.opacity = 0;
                        this.locked = false;
                    }

                    // Smooth Lock Value for Visuals
                    this.lockVal += (targetLock - this.lockVal) * 0.1;
                    Visuals.mat.uniforms.uLock.value = this.lockVal;
                };

                const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6});
                faceMesh.onResults(onResults);
                
                new Camera(video, { onFrame: async () => await faceMesh.send({image: video}), width: 640, height: 480 }).start();
            },

            initUI: function() {
                const wrapper = document.getElementById('scan-wrapper');
                const resync = document.getElementById('resync-btn');
                const overlay = document.getElementById('result-overlay');

                // --- 1. NUCLEAR TOUCH EVENT (e.preventDefault) ---
                // This stops iOS magnifier/menu instantly.
                const handleStart = (e) => {
                    e.preventDefault(); // THE KEY
                    if(!this.locked) return;

                    wrapper.classList.add('active');
                    this.playWarp();
                };

                // Add both touch and mouse listeners for compatibility
                wrapper.addEventListener('touchstart', handleStart, {passive: false});
                wrapper.addEventListener('mousedown', handleStart);

                resync.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.reset();
                });
                resync.addEventListener('click', () => this.reset());
            },

            playWarp: function() {
                // Audio (Sawtooth Rise)
                const ctx = new (window.AudioContext||window.webkitAudioContext)();
                const o=ctx.createOscillator(); const g=ctx.createGain();
                o.type='sawtooth'; o.frequency.value=60; o.frequency.exponentialRampToValueAtTime(800, ctx.currentTime+1.5);
                g.gain.value=0.2; g.gain.linearRampToValueAtTime(0, ctx.currentTime+1.5);
                o.connect(g); g.connect(ctx.destination); o.start();

                // Warp Animation
                let start = performance.now();
                const dur = 1500;
                const frame = (now) => {
                    let p = (now - start) / dur;
                    if(p>1) p=1;
                    // Expo ease in
                    Visuals.mat.uniforms.uWarp.value = p * p * p * p;
                    if(p<1) requestAnimationFrame(frame);
                    else this.showResult();
                };
                requestAnimationFrame(frame);
            },

            showResult: function() {
                document.getElementById('scan-wrapper').classList.remove('active');
                
                const finalScore = Math.floor(Math.random()*(99-72)+72);
                
                // --- 2. DECRYPTION EFFECT (Rolling Numbers) ---
                const scoreEl = document.getElementById('final-score');
                let rolls = 0;
                const rollInterval = setInterval(() => {
                    scoreEl.innerText = Math.floor(Math.random()*99); // Chaos
                    rolls++;
                    if(rolls > 20) {
                        clearInterval(rollInterval);
                        scoreEl.innerText = finalScore; // Lock
                        
                        // Show Text
                        const st = document.getElementById('state-text');
                        st.style.opacity = 1;
                        if(finalScore > 90) { st.innerText="FLOW STATE"; st.style.color="#00FF9D"; }
                        else { st.innerText="OPTIMAL"; st.style.color="#00F0FF"; }
                    }
                }, 30); // Fast update

                document.getElementById('result-overlay').classList.add('show');
            },

            reset: function() {
                document.getElementById('result-overlay').classList.remove('show');
                Visuals.mat.uniforms.uWarp.value = 0;
                document.getElementById('state-text').style.opacity = 0;
            }
        };

        window.onload = () => App.init();
    </script>
</body>
</html>
