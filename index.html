<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TENKI v27.0 - Hyper Flux</title>
    
    <!-- Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        :root {
            --bg-deep: #000000;
            --tei-core: #00F0FF;
            --tei-surge: #FFFFFF;
        }

        body {
            background: var(--bg-deep);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            width: 100vw; height: 100vh;
            margin: 0; padding: 0;
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
        }

        #input-video, #process-canvas { opacity: 0; pointer-events: none; position: fixed; top: -9999px; }

        /* 3D Scene */
        #universe {
            position: absolute; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #050a10 0%, #000000 100%);
        }

        /* HUD Layer */
        #hud-layer {
            position: absolute; inset: 0; z-index: 20;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        /* 戰鬥機準心系統 (Sniper Reticle) */
        #reticle {
            position: absolute; top: 50%; left: 50%;
            width: 240px; height: 320px;
            transform: translate(-50%, -55%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 100px; /* 臉型 */
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 15;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.85); /* 聚焦暗角 */
        }
        
        /* 十字準星 */
        #reticle::before, #reticle::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.2);
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            transition: all 0.3s;
        }
        #reticle::before { width: 20px; height: 1px; } /* 橫線 */
        #reticle::after { width: 1px; height: 20px; } /* 直線 */

        /* 鎖定狀態特效 */
        #reticle.locked {
            border-color: #00F0FF;
            border-width: 2px;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.6); /* 變亮 */
            width: 260px; height: 340px; /* 微微放大 */
        }
        #reticle.locked::before, #reticle.locked::after {
            background: #00F0FF;
            width: 40px; height: 2px; /* 十字變大 */
        }
        #reticle.locked::after { width: 2px; height: 40px; }

        /* 狀態文字 */
        #align-msg {
            position: absolute; top: -30px; width: 100%; text-align: center;
            font-family: 'Courier New', monospace; font-size: 10px; letter-spacing: 2px;
            color: rgba(255,255,255,0.4);
        }

        /* Go Club Button */
        .go-btn {
            pointer-events: auto;
            background: #FFFFFF; color: #000000;
            font-weight: 900; font-size: 14px; letter-spacing: 1px;
            padding: 16px 40px;
            border-radius: 999px;
            border: none;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
            display: flex; align-items: center; gap: 8px;
            transition: transform 0.1s;
        }
        .go-btn:active { transform: scale(0.92); }

        /* Fingerprint Sensor */
        .fingerprint-sensor {
            pointer-events: auto;
            position: relative;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0.5; /* 預設半透明 */
        }
        .fingerprint-sensor.ready { opacity: 1; border-color: white; }
        .fingerprint-sensor.active {
            transform: scale(1.2);
            background: rgba(0, 240, 255, 0.2);
            border-color: #00F0FF;
            box-shadow: 0 0 60px #00F0FF;
        }

        /* Result Overlay */
        #result-overlay {
            position: absolute; inset: 0; z-index: 50;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
            backdrop-filter: blur(30px);
        }
        #result-overlay.show { opacity: 1; pointer-events: auto; }

        .score-hero {
            font-size: 120px; font-weight: 900;
            background: linear-gradient(180deg, #fff, #555);
            -webkit-background-clip: text; color: transparent;
            letter-spacing: -6px; line-height: 0.9;
        }
    </style>
</head>
<body>
    <video id="input-video" playsinline></video>

    <div id="universe"></div>

    <!-- Alignment System -->
    <div id="reticle">
        <div id="align-msg">ALIGN CROSSHAIR</div>
    </div>

    <!-- HUD -->
    <div id="hud-layer">
        <div class="flex justify-between items-start">
            <div>
                <div class="text-2xl font-black tracking-widest text-white">TENKI</div>
                <div class="text-[9px] text-cyan-400 tracking-[0.3em] mt-1">v27.0 HYPER_FLUX</div>
            </div>
            <div id="system-status" class="text-[9px] font-mono text-gray-500 border border-gray-800 px-2 py-1 rounded">
                INIT...
            </div>
        </div>

        <div class="flex flex-col items-center pb-16">
            <div id="scan-trigger" class="fingerprint-sensor">
                <i data-lucide="fingerprint" class="w-8 h-8 text-white"></i>
            </div>
            <div id="hint" class="mt-6 text-[9px] tracking-[4px] text-gray-400 font-mono uppercase">
                Acquiring Target...
            </div>
        </div>
    </div>

    <!-- Result -->
    <div id="result-overlay">
        <div class="text-[10px] tracking-[6px] text-gray-500 mb-6 font-mono">TEI INDEX</div>
        <div class="score-hero" id="final-score">--</div>
        <div id="state-text" class="mt-4 text-xl font-bold tracking-[0.2em] text-cyan-400">ANALYZING</div>

        <div class="grid grid-cols-3 gap-8 mt-16 text-center w-full px-8">
            <div><div class="text-2xl font-bold text-white" id="val-1">--</div><div class="text-[9px] text-gray-600 mt-2 font-mono">STABILITY</div></div>
            <div><div class="text-2xl font-bold text-white" id="val-2">--</div><div class="text-[9px] text-gray-600 mt-2 font-mono">ENERGY</div></div>
            <div><div class="text-2xl font-bold text-white" id="val-3">--</div><div class="text-[9px] text-gray-600 mt-2 font-mono">FOCUS</div></div>
        </div>

        <div class="mt-20">
            <button id="resync-btn" class="go-btn">
                <i data-lucide="zap" class="w-4 h-4"></i> REBOOT
            </button>
        </div>
    </div>

    <script>
        lucide.createIcons();

        // --- 1. Hyper-Flux Engine (Shader) ---
        // 這是 2050 年的靈魂。粒子不再只是點，它們是流體。
        const Shaders = {
            vertex: `
                attribute float size; attribute float random;
                uniform float uTime;
                uniform float uEnergy;  // 總能量 (0-1)
                uniform vec2 uHeadRot;  // 頭部旋轉
                uniform float uWarp;    // 曲速 (掃描時觸發)
                
                varying vec3 vColor;
                varying float vAlpha;

                // 雜訊函數 (模擬流體)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 = v - i + dot(i, C.xxx) ;
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                    float n_ = 0.142857142857;
                    vec3  ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                }

                void main() {
                    vec3 pos = position;
                    
                    // 1. 旋轉與互動 (球體旋轉，但位置鎖死在中心)
                    // 使用旋轉矩陣來旋轉球體，而不是移動它
                    float angleY = uHeadRot.x * 2.0; 
                    float angleX = uHeadRot.y * 2.0;
                    
                    mat3 rotY = mat3(cos(angleY), 0.0, sin(angleY), 0.0, 1.0, 0.0, -sin(angleY), 0.0, cos(angleY));
                    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, sin(angleX), cos(angleX));
                    
                    pos = rotY * rotX * pos;

                    // 2. Hyper-Flux Noise (狂暴流體)
                    // 當能量(張嘴)高時，粒子會產生極大的雜訊位移
                    float noise = snoise(pos * 1.5 + uTime * 2.0);
                    float flux = uEnergy * 2.5; // 放大能量反應
                    pos += normal * noise * flux;

                    // 3. Warp Drive (曲速引擎 / 溢出畫面)
                    // 當 uWarp 啟動(掃描時)，粒子向Z軸(鏡頭)衝刺，製造穿越星空的感覺
                    pos.z += uWarp * 10.0 * random; 
                    pos.x *= (1.0 + uWarp * 2.0); // 寬度擴張
                    pos.y *= (1.0 + uWarp * 2.0); // 高度擴張

                    // 4. Position
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    // 5. Size Dynamics
                    float sizeMult = 1.0 + uEnergy * 3.0; // 能量越高粒子越大
                    gl_PointSize = size * sizeMult * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;

                    // 6. Color Shift (Blue -> White Hot)
                    vec3 cCore = vec3(0.0, 0.8, 1.0); // Cyber Blue
                    vec3 cSurge = vec3(1.0, 1.0, 1.0); // White Hot
                    
                    vColor = mix(cCore, cSurge, uEnergy * 0.8 + uWarp);
                    vAlpha = 0.5 + uEnergy * 0.5;
                }
            `,
            fragment: `
                varying vec3 vColor; varying float vAlpha;
                void main() {
                    float r = distance(gl_PointCoord, vec2(0.5));
                    if(r > 0.5) discard;
                    float glow = 1.0 - (r * 2.0);
                    glow = pow(glow, 2.0);
                    gl_FragColor = vec4(vColor, glow * vAlpha);
                }
            `
        };

        // --- 2. Main System ---
        const App = {
            init: function() {
                this.initThree();
                this.initAI();
                this.initEvents();
            },

            // --- 3D Environment ---
            initThree: function() {
                const container = document.getElementById('universe');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                
                // FIXED CENTER: 鏡頭位置固定，不隨頭部移動
                // 直屏時拉遠一點，讓球體完整呈現
                this.camera.position.z = window.innerWidth < window.innerHeight ? 6.0 : 4.5;

                this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                // Particles (10k for density)
                const geo = new THREE.BufferGeometry();
                const count = 10000;
                const pos = [], rnd = [], sz = [];
                for(let i=0; i<count; i++){
                    // Fibonacci Sphere
                    const phi = Math.acos(-1 + (2*i)/count);
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    const r = 2.0 + Math.random()*0.2;
                    pos.push(r*Math.cos(theta)*Math.sin(phi), r*Math.sin(theta)*Math.sin(phi), r*Math.cos(phi));
                    rnd.push(Math.random()); 
                    sz.push(0.08 + Math.random()*0.1);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                geo.setAttribute('random', new THREE.Float32BufferAttribute(rnd,1));
                geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));
                geo.computeVertexNormals();

                this.mat = new THREE.ShaderMaterial({
                    uniforms: { 
                        uTime: {value:0}, uEnergy: {value:0}, uHeadRot: {value:new THREE.Vector2()}, uWarp: {value:0}
                    },
                    vertexShader: Shaders.vertex, fragmentShader: Shaders.fragment,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });
                this.scene.add(new THREE.Points(geo, this.mat));

                const animate = () => {
                    requestAnimationFrame(animate);
                    const t = performance.now()*0.001;
                    this.mat.uniforms.uTime.value = t;
                    
                    // Idle Rotation (Slowly turning universe)
                    this.scene.rotation.y = t * 0.05;

                    this.renderer.render(this.scene, this.camera);
                };
                animate();

                // Responsive
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.position.z = window.innerWidth < window.innerHeight ? 6.0 : 4.5;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },

            // --- AI & Logic ---
            initAI: function() {
                const video = document.getElementById('input-video');
                const reticle = document.getElementById('reticle');
                const alignMsg = document.getElementById('align-msg');
                const sysStatus = document.getElementById('system-status');
                const sensorBtn = document.getElementById('scan-trigger');
                
                // State
                this.locked = false;
                this.energy = 0;

                const onResults = (res) => {
                    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
                        const lm = res.multiFaceLandmarks[0];
                        const nose = lm[1];

                        // --- 1. Sniper Alignment Logic ---
                        // 判定範圍極小 (0.45 - 0.55)，強迫使用者完美置中
                        const centerX = Math.abs(nose.x - 0.5);
                        const centerY = Math.abs(nose.y - 0.5);
                        const isAligned = centerX < 0.05 && centerY < 0.08;

                        if (isAligned) {
                            if (!this.locked) {
                                this.locked = true;
                                reticle.classList.add('locked');
                                alignMsg.innerText = "TARGET LOCKED"; alignMsg.style.color = "#00F0FF";
                                sysStatus.innerText = "READY"; sysStatus.style.color = "#00F0FF"; sysStatus.style.borderColor = "#00F0FF";
                                sensorBtn.classList.add('ready');
                                if(navigator.vibrate) navigator.vibrate(20);
                            }
                        } else {
                            if (this.locked) {
                                this.locked = false;
                                reticle.classList.remove('locked');
                                alignMsg.innerText = "ALIGN CENTER"; alignMsg.style.color = "rgba(255,255,255,0.4)";
                                sysStatus.innerText = "ALIGNING"; sysStatus.style.color = "gray"; sysStatus.style.borderColor = "#333";
                                sensorBtn.classList.remove('ready');
                            }
                        }

                        // --- 2. Energy Extraction ---
                        // Mouth + Brow + Eye jitter
                        const mouthOpen = Math.min(1, Math.abs(lm[13].y - lm[14].y) * 15.0);
                        const browTens = Math.min(1, Math.abs(lm[334].y - lm[296].y) * 20.0);
                        
                        // Target Energy
                        const targetEnergy = mouthOpen + (1-browTens)*0.2;
                        // Smooth Lerp
                        this.energy += (targetEnergy - this.energy) * 0.2;
                        
                        // Send to Shader (Direct Control)
                        this.mat.uniforms.uEnergy.value = this.energy;
                        
                        // Head Rotation for Shader (Only Rotation, No Position Shift)
                        this.mat.uniforms.uHeadRot.value.set((nose.x-0.5)*-3.0, (nose.y-0.5)*-3.0);

                    } else {
                        // Lost Face
                        this.locked = false;
                        reticle.classList.remove('locked');
                        alignMsg.innerText = "NO SIGNAL";
                        this.mat.uniforms.uEnergy.value *= 0.9; // Decay
                    }
                };

                const faceMesh = new FaceMesh({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.6});
                faceMesh.onResults(onResults);
                
                const camera = new Camera(video, {
                    onFrame: async () => await faceMesh.send({image: video}),
                    width: 640, height: 480
                });
                camera.start();
            },

            // --- Events ---
            initEvents: function() {
                const btn = document.getElementById('scan-trigger');
                const resync = document.getElementById('resync-btn');
                const hint = document.getElementById('hint');

                // Pointerdown = Zero Delay
                btn.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    if(!this.locked) return; // Must be locked

                    btn.classList.add('active');
                    hint.innerText = "QUANTUM TUNNEL OPENING...";
                    
                    // Activate Warp Drive
                    this.playWarpAnimation();
                });

                resync.addEventListener('pointerdown', () => {
                    document.getElementById('result-overlay').classList.remove('show');
                    hint.innerText = "ACQUIRING TARGET...";
                    // Reset Warp
                    this.mat.uniforms.uWarp.value = 0;
                });
            },

            playWarpAnimation: function() {
                // WARP DRIVE LOGIC
                // 讓 uWarp 在 2秒內從 0 衝到 1，製造穿越效果
                let start = performance.now();
                const duration = 2000;
                
                const frame = (now) => {
                    let progress = (now - start) / duration;
                    if(progress > 1) progress = 1;
                    
                    // Ease In Expo
                    const warpVal = progress === 0 ? 0 : Math.pow(2, 10 * progress - 10);
                    this.mat.uniforms.uWarp.value = warpVal;

                    if(progress < 1) {
                        requestAnimationFrame(frame);
                    } else {
                        this.showResult();
                    }
                };
                requestAnimationFrame(frame);
                
                // Audio
                const ctx = new (window.AudioContext||window.webkitAudioContext)();
                const o = ctx.createOscillator(); const g = ctx.createGain();
                o.type='sawtooth'; o.frequency.value=60; o.frequency.exponentialRampToValueAtTime(800, ctx.currentTime+2);
                g.gain.value=0.2; g.gain.linearRampToValueAtTime(0, ctx.currentTime+2);
                o.connect(g); g.connect(ctx.destination); o.start();
            },

            showResult: function() {
                document.getElementById('scan-trigger').classList.remove('active');
                
                // Random Score for Demo
                const score = Math.floor(Math.random() * (99 - 65) + 65);
                document.getElementById('final-score').innerText = score;
                
                document.getElementById('val-1').innerText = (Math.random()*20+80).toFixed(0) + '%';
                document.getElementById('val-2').innerText = (Math.random()*20+80).toFixed(0) + '%';
                document.getElementById('val-3').innerText = (Math.random()*20+80).toFixed(0) + '%';

                document.getElementById('result-overlay').classList.add('show');
            }
        };

        window.onload = () => App.init();
    </script>
</body>
</html>
